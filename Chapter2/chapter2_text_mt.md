# 2. コンパイラ

この本ではプログラミング言語Erlangは扱いませんが、ERTSのゴールはErlangコードを実行することなので、Erlangコードのコンパイル方法を知っている必要があります。この章では読みやすいビームコードを生成するために必要なコンパイラのオプションと、生成されたビームファイルにデバッグ情報を追加する方法について説明します。この章の終わりにはElixirコンパイラについてのセクションもあります。

自分の好きな言語をERTSにコンパイルすることに興味がある読者のために、この章ではコンパイラのさまざまな中間フォーマットや、あなたのコンパイラをbeamコンパイラバックエンドにプラグインする方法についての詳細情報も提供します。また、構文解析変換を紹介し、それを使ってErlang言語を調整する方法の例も挙げます。

## 2.1. Erlangのコンパイル

Erlangは.erlファイルにあるソースコードモジュールからファットバイナリの.beamファイルにコンパイルされます。

コンパイラはOSのシェルからerlcコマンドで実行することができます。

```
> erlc foo.erl
```

あるいは、コンパイラはErlangシェルからデフォルトのシェルコマンド c を使って起動することもできますし、 compile:file/{1,2} を呼び出して起動することもできます。

```
1> c(foo).
```

または、

```
1> compile:file(foo).
```

compile:file のオプションの第二引数は、コンパイラのオプションのリストです。オプションの完全なリストは compile モジュールのドキュメントにあります: http://www.erlang.org/doc/man/compile.html を参照してください。

通常、コンパイラはErlangのソースコードを.erlファイルからコンパイルして、結果のバイナリビームコードを.beamファイルに書き出します。コンパイラにbinaryオプションを与えることで、結果のバイナリをErlangの項として返すこともできます。このオプションはオーバーロードされ、ファイルに書き込む代わりに任意の中間フォーマットを項として返すようになりました。例えば、コンパイラにCore Erlangコードを返させたい場合は、[core, binary]というオプションを指定します。

コンパイラは、図6に示すように、いくつかのパスから構成されている。

Figure 6. Compiler Passes <img width="650" alt="qiita-square" src="figure/Figure 6. Compiler Passes.png">

もしコンパイラパスの完全で最新のリストを見たいなら、Erlangシェルでcompile:options/0という関数を実行することができます。コンパイラに関する情報の決定的なソースはもちろんソースです： compile.erl